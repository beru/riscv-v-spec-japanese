5. ベクトル命令フォーマット
---------------------------

ベクトル拡張命令は既存の4つの命令オペコード(LOAD-FP, STORE-FP,
AMO)および新しいメジャーオペコード(OP-V)を使用している。

ベクトルロードとストア命令は浮動小数点巣からロードストアのメジャーオペコード(LOAD-FP/STORE-FP)でエンコーディングされている。ベクトルロードとストアは標準的なスカラの浮動小数点ロードストア命令の12ビットの即値フィールドを使って、より多くの命令エンコーディングを提供している。ビット25は標準的なベクトルマスクビットを示している(マスクエンコーディングの章を参照のこと)。

::

   LOAD-FPメジャーオペコードを使用したベクトルロード命令のフォーマット
   31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
    nf  | mop | vm |  lumop   |    rs1    | width |    vd   |0000111| VL*  unit-stride
    nf  | mop | vm |   rs2    |    rs1    | width |    vd   |0000111| VLS* strided
    nf  | mop | vm |   vs2    |    rs1    | width |    vd   |0000111| VLX* indexed
     3     3     1      5           5         3         5       7

   STORE-FPメジャーオペコードを使用を使用したベクトルストア命令のフォーマット
   31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
    nf  | mop | vm |  sumop   |    rs1    | width |   vs3   |0100111| VS*  unit-stride
    nf  | mop | vm |   rs2    |    rs1    | width |   vs3   |0100111| VSS* strided
    nf  | mop | vm |   vs2    |    rs1    | width |   vs3   |0100111| VSX* indexed
     3     3     1      5           5         3         5        7

::

   AMOメジャーオペコードを使用したベクトルAMO命令のフォーマット
   31    27 26  25  24      20 19       15 14   12 11      7 6     0
    amoop  |wd| vm |   vs2    |    rs1    | width | vs3/vd  |0101111| VAMO*
      5      1   1      5           5         3        5        7

::

   OP-Vメジャーオペコードを使用したベクトル算術演算のフォーマット

   31       26  25   24      20 19      15 14   12 11      7 6     0
     funct6   | vm  |   vs2    |    vs1   | 0 0 0 |    vd   |1010111| OP-V (OPIVV)
     funct6   | vm  |   vs2    |    vs1   | 0 0 1 |  vd/rd  |1010111| OP-V (OPFVV)
     funct6   | vm  |   vs2    |    vs1   | 0 1 0 |  vd/rd  |1010111| OP-V (OPMVV)
     funct6   | vm  |   vs2    |   simm5  | 0 1 1 |    vd   |1010111| OP-V (OPIVI)
     funct6   | vm  |   vs2    |    rs1   | 1 0 0 |    vd   |1010111| OP-V (OPIVX)
     funct6   | vm  |   vs2    |    rs1   | 1 0 1 |    vd   |1010111| OP-V (OPFVF)
     funct6   | vm  |   vs2    |    rs1   | 1 1 0 |  vd/rd  |1010111| OP-V (OPMVX)
        6        1        5          5        3        5        7

::

   OP-Vメジャーオペコードを使用したベクトルコンフィグレーションのフォーマット

    31 30         25 24      20 19      15 14   12 11      7 6     0
    0 |        zimm[10:0]      |    rs1   | 1 1 1 |    rd   |1010111| vsetvli
    1 |   000000    |   rs2    |    rs1   | 1 1 1 |    rd   |1010111| vsetvl
    1        6            5          5        3        5        7

ベクトル命令はスカラオペランドとベクトルソースオペランドを持つことができ、スカラとベクトルの両方の結果を出力することができる。ほとんどのベクトル命令は無条件で動作するか、マスクに基づいて条件的に動作する。

ベクトルロードストア命令はレジスタ要素とメモリの間でビットパタンを移動する。ベクトル算術演算はベクトルレジスタ要素の値を演算する。

5.1. スカラオペランド
~~~~~~~~~~~~~~~~~~~~~

スカラオペランドは、即値、\ ``X``\ 整数レジスタ、\ ``f``\ 浮動小数点レジスタ、ベクトルの要素0レジスタを取ることができる。スカラの結果は\ ``X``,
\`f,
もしくはベクトルレジスタの要素0番目に書き込まれる。LMULのセッティングに関係なく、どのようなベクトルレジスタもスカラの値を保持することができる。

   0.6からの仕様変更として、浮動小数点レジスタはベクトルレジスタとオーバレイしなくなった点と、スカラの要素嘘として整数と浮動小数点レジスタを取ることができるということが挙げられる。\ ``f``\ レジスタとのオーバレイの仕様を削除したことにより、ベクトルレジスタのレジスタプレッシャの問題を削減し、標準的な呼び出し規約での相互干渉を避けることができる。また、高性能スカラ浮動小数点演算命令において実装を簡単化する。また、Zfinx
   ISAとの互換性をサポートする。\ ``f``\ レジスタを\ ``v``\ レジスタとオーバレイすることのメリットはいくつかの実装で状態ビットの数を削減することができるが、高性能な設計では実装が複雑化し、Zfinxオプションでの処理が複雑化する。

5.2. ベクトルオペランド
~~~~~~~~~~~~~~~~~~~~~~~

ベクトルオペランド・ベクトル演算結果はLMULに基づいて1つ以上のベクトルレジスタを使用するが、常にグループ内の最小ベクトルレジスタアドレスを使用する。最小ベクトルレジスタアドレス以外を使用すると、不定命令例外を発生する。

いくつかのベクトル命令はより幅の長い要素を読み込むか書き込みを行い、\ ``vlmul``\ で指定されたレジスタグループよりもより多くのベクトルレジスタグループを使用することがある。最大のベクトルレジスタグループは8を超える事は無く、もしベクトル命令が8よりも大きなレジスタグループを必要とするならば、その命令は不定命令例外が発生する。例えば、LMUL=8でより幅の広いレジスタを使用する命令を実行した場合、不定命令例外が発生する。

5.3 ベクトルマスク
~~~~~~~~~~~~~~~~~~

多くのベクトル命令ではマスクイングをサポートしている。マスクされた要素に対する演算は、書き込みレジスタ要素の値を更新せず、例外も発生しない。

ベースレジスタ拡張では、マスクの値はマスク付きベクトル命令によって使用され、マスクの値は常にベクトルレジスタ\ ``v0``\ から与えられる。各要素の再開ビットが制御命令のマスクベクタとして使用される。

   将来のベクトル拡張では、マスクレジスタとしてすべての空間を利用できるような長い命令エンコーディングを提供する予定である。

マスク付きベクトル命令の書き込みレジスタグループは、LMUL=1の時のみおーばラップすることができる。それ以外の場合は不定命令例外が発生する。

   この制約では、非ゼロの\ ``vstart``\ 値による再開がサポートされる。

他のベクトルレジスタは計算中のマスクを保持することができ、プレディケートの計算のためにベクトル論理演算などを適用できる。

5.3.1. マスクのエンコーディング
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

マスクが使用可能な場合、命令中の\ ``inst[25]``\ に配置されている\ ``vm``\ 1ビットとしてエンコードされる。

+----+-----------------------------------------+
| vm | 説明                                    |
+====+=========================================+
| 0  | vector result, only where v0[i].LSB = 1 |
+----+-----------------------------------------+
| 1  | unmasked                                |
+----+-----------------------------------------+

..

   初期の仕様では、\ ``vm``\ は2ビットであり\ ``vm[1:0]``\ とし、スカラ命令と同様に\ ``v0``\ を使用して双方とも1もしくは排他的なマスクをサポートしていた。

ベクトルのマスクはアセンブラコードでは追加のベクトルオペランドとして表現される。\ ``.t``\ は\ ``v0[i].LSB``\ が1である場合に演算が発生する。マスクが指定されていないと、マスク無しベクトル命令(\ ``vm=1``)として演算が実行される。

::

       vop.v*    v1, v2, v3, v0.t  # enabled where v0[i].LSB=1, m=0
       vop.v*    v1, v2, v3        # unmasked vector operation, m=1

..

   ``v0``\ によるTrueの形のプレディケーションをベクトルマスクレジスタをサポートしているにも関わらず、アセンブリの構文ではマスクレジスタの指定としてすべてのベクトルレジスタを指定でき、Both
   Trueと排他的なマスクをサポートできるように設計している。\ ``.t``\ はマスクの仕様を視覚的にエンコードすることを助ける。

5.4 プリスタート・アクティブ・インアクティブ・ボディー・テールの要素定義
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ベクトル命令を実行中に、演算が適用される要素は以下の4つの別々の状態に分類される。

-  **プリスタート(prestart)**
   要素は、その要素のインデックが\ ``vstart``\ に格納されている初期値よりも小さいものを指す。プリスタート状態の要素は例外を発生させず、書き込みレジスタに指定されても要素のアップデートは行われない。
-  **アクティブ(active)**\ 要素は現在のベクトル長の設定に含まれているベクトル要素であり、現在のマスク設定により有効化されている要素である。アクティブな要素は例外を発生する可能性があり、書き込みベクトルレジスタグループにより書き込みが発生する可能性がある。
-  **インアクティブ(inactive)**\ な要素は現在のベクトル長の設定に含まれているベクトル要素であるが、現在のマスクそっていにより有効化されていないベクトル要素である。インアクティブな要素は例外を発生させず、書き込みレジスタに指定されても書き込みが行われない。
-  **テール(tail)**\ 要素はベクトル命令の実行中に、現在のベクトル長の設定よりも後ろのベクトル要素である。テールのベクトル要素は例外を発生させないが、ベクトルレジスタグループにおいて書き込み時はゼロが書き込まれる。
-  加えて、他の要素として\ **ボディー(body)**\ 要素は、アクティブ要素とインアクティブ要素の両方を示したものである。つまり、プリスタート以降で、テール以前の要素を指す。

::

       ベクトル要素のインデックス xについて、
       プリスタート     = (0 <= x < vstart)
       mask(x)        = unmasked || v0[x].LSB == 1
       アクティブ(x)    = (vstart <= x < vl) && mask(x)
       インアクティブ(x) = (vstart <= x < vl) && !mask(x)
       ボディー(x)      = active(x) || inactive(x)
       テール(x)        = (vl <= x < VLMAX)

すべての通常ベクトル命令は、書き込みレジスタのテール要素に対してゼロを書き込む。いくつかのベクトル算術演算はマスク不可能であり、したがってインアクティブな要素は存在しないが、テール要素についてはゼロを書き込む。

   インアクティブとテール要素のアップデートルールは、実装の要求とベクトルレジスタのECCの問題およびリネーミングに関する問題の妥協案として設計されている。

..

   ``vl``\ 以降のレジスタをゼロ埋めしないと、リネーミングを行う実装において悪影響があり、すべての命令においてVL以降のすべての要素をコピーする必要がある。一方でリネーミングを行わない実装ではテールのゼロ化を行うことのペナルティは小さい。リネーミングを行う実装では、リネーミングを行わないことですべてのベクトルレジスタのコピーを避けることができ、各レジスタの演算が、任意のベクトル長に対してすべての帯域を占有してしまうだけに十分深くなってしまうことが問題である。\ ``vl``\ 以降の値をすべてゼロで埋めてしまうことにより、ほとんどのソフトウェアの影響を削減するが、リダクション捜査の場合にも若干のコストが発生する。

   テール意向をゼロに埋めるために、一時的に長いベクトルレジスタを使用する実装では、レジスタのリネーミングの有無にかかわらず、実際にゼロを書き込む操作を割くるために新たなマイクロアーキテクチャの状態を追加することも考えられるが、これは比較的単純なマイクロアーキテクチャの最適化である。例えば、要素グループ毎に1ビット、もしくは量子化されたVLによりゼロ埋めを行う範囲を追跡することができる。要素グループは、マイクロアーキテクチャの実行の最小アトミックユニット単位(多くの場合、マシンの物理データパスのサイズと同じ)を構成する要素のセットとなる。要素グループのマイクロアーキテクチャの状態は、読み出し時には要素グループにゼロが返され、マスクされた要素に対する書き込みは、最初の書き込み時にグループ内のマスクされた要素にゼロを代入されることを示す(その後、要素グループのゼロビットはクリアできる)。

..

   マスクされたインアクティブな要素をゼロ埋めする方法の代わりに、マージプレディケートを実装することにより、多くのコードブロックのコードパスの長さが短くなり、異なるコードパスが同じベクトルレジスタ内の要素の異なる要素の集合を使用できるため、レジスタプレッシを軽減することができる。ベクトルレジスタのECC、もしくはリネーミングを使用する実装では、算術命令のインアクティブな要素を保持するために、読み取り/更新/書き込みを実行する必要あり、ベクトルレジスタの読み取りポートを増やす必要がある。ただし、算術命令は、最大の読み取りポート数が1つのソースを上書きするFused積和命令であるように設計されているため、インアクティブな要素を保持するための追加の読み取りポートは必要ない。線形代数はベクトル単位のより重要なアプリケーションの1つであり、線形積和が線形代数ルーチンの主要な演算であるため、マイクロアーキテクチャはFused積和演算に対して最適化され、インアクティブな要素を保持できるはずである。大きな追加コストなしで他の算術演算も実装できる。ただし、マスクされたベクトルロード命令では、デスティネーションレジスタに追加の読み取りポートのコストが発生する。ゼロ以外の\ ``vstart``\ 値でリジューム可能なベクトルロードをサポートする必要性があり、ベクトルロードデスティネーションレジスタ値を保持する必要性も発生する。
   AMOは、メモリパイプの最大リードポートの数を減らすために、ソースオペランドを上書きするように設計されている。ほかの方法として考えられたものは、算術命令とは異なる動作をロードに与え、マスクされた要素をゼロにすることであった。しかしこの方法では追加の命令が必要であり、レジスターのプレッシャーが増加する。ベクタロードは、いずれの場合でも、何らかのメカニズムを介してゼロ以外の\ ``vstart``\ 値に対処する必要がある。
